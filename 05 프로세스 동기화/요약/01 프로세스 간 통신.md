## 1. 프로세스 간 통신의 개념

프로세스 간 통신(Inter Process Communication, IPC) : 다른 프로세스와 데이터를 주고 받는 것

- 프로세스 내부 데이터 통신 : 하나의 프로세스 내에 2개 이상의 스레드가 존재하는 경우 → 전역 변수나 파일을 이용
- 프로세스 간 데이터 통신 : 같은 컴퓨터에 있는 여러 프로세스끼리 → 공용 파일 또는 운영체제가 제공하는 파이프 이용
- 네트워크를 이용한 데이터 통신(=네트워킹) : 여러 컴퓨터가 네트워크로 연결된 경우 → 소켓 이용

⚠ 통신 방식을 결정할 때는 **오버헤드를 고려**해야 한다. 예를 들어 같은 컴퓨터에 있는 프로세스끼리도 소켓을 이용해 통신할 수 있다. IP 주소로 127.0.0.1과 같이 루프백 주소를 사용하면 된다. 다만 많은 전처리를 해야 하므로 느리다.

프로세스 간 통신 방식은 데이터를 주거나(send) 받는(receive) 것이 전부다. 내부적으로는 통신하려는 상대 프로세스를 어떻게 찾을지, 데이터의 크기는 얼마로 할지, 데이터 도착 여부를 어떻게 확인할지 등의 여러 문제를 포함한다.

## 2. 프로세스 간 통신의 분류

### 1) 통신 방향에 따른 분류

***프로세스 간 통신***은 동시에 실행되는 프로세스끼리 데이터를 주고받는 작업을 의미한다. ***함수 호출***도 데이터를 주고받긴 하지만 하나의 프로세스 내에서 순차적으로 실행되므로 통신이라고 부르지 않는다.

- 양방향 통신 : 데이터를 동시에 양쪽으로 전송 가능. 일반적인 통신은 모두 양방향 통신. e.g.) 소켓 통신
- 반양방향 통신 : 데이터를 양쪽으로 전송 가능하나 동시에는 불가능. e.g.) 무전기
- 단방향 통신 : 한쪽으로만 데이터 전송 가능. e.g.) 모스 신호, 전역 변수, 파이프

### 2) 통신 구현 방식에 따른 분류

**바쁜 대기** : ****전역 변수를 사용하는 통신 방식에서는 언제 데이터를 보낼지 데이터를 받는 쪽에서 알 수가 없다. 상태 변화를 살펴보기 위해 반복문을 무한 실행하며 기다려야 한다.(busy waiting)

**동기화** : 데이터가 도착했음을 알려주는 것.

- 대기가 있는 통신(동기화 통신) : 동기화 지원. 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기 상태에 머물러 있다.
- 대기가 없는 통신(비동기화 통신) : 동기화 지원X. 데이터를 받는 쪽은 바쁜 대기를 사용하여 데이터가 도착했는지 여부를 직접 확인한다.

![https://user-images.githubusercontent.com/57691894/192102932-01b28382-dd4e-487c-b362-29290affaf63.png](https://user-images.githubusercontent.com/57691894/192102932-01b28382-dd4e-487c-b362-29290affaf63.png)

## 3. 프로세스 간 통신의 종류

통신에서 가장 중요한 것은 프로세스 동기화이다. 전역 변수, 파일, 파이프, 소켓을 이용한 프로세스 간 통신과 동기화 방식에 대해 알아보도록 한다.

### 1) 전역 변수를 이용한 통신

공동으로 관리하는 메모리를 사용하여 데이터를 주고받는 것. 데이터를 받는 쪽은 전역 변수의 값이 변할 때까지 *바쁜 대기*를 돌면서 계속 주시해야 한다.

- 보내는 쪽 : 전역 변수나 파일에 값을 쓴다.
- 받는 쪽 : 전역 변수의 값을 읽는다.

주로 직접적으로 관련이 있는 프로세스 간에 사용한다. 예로, 부모 프로세스가 전역 변수를 선언한 후 자식 프로세스를 만들면 부모 프로세스와 자식 프로세스가 통신을 할 수 있다.

### 2) 파일을 이용한 통신

저장장치에 파일을 쓰고 읽는 방식.

파일 입출력 과정은 세 부분으로 구성되어 있다.

1. 파일 열기(open)
    
    사용하고자 하는 파일이 있는지, 있다면 어떤 권한이 있는지 확인한다. 정상적으로 파일을 사용할 수 있다면 파일 기술자(file descripter)를 반환받는다.
    
2. 쓰기(write) 또는 읽기(read)
    
    파일을 열어서 받은 fd에는 파일에 대한 접근 권한을 가지고 있다. fd로 파일을 쓰거나 읽는다.
    
3. 파일 닫기(close)
    
    fd가 가리키는 파일을 닫으면서 자원을 반납한다.
    

프로세스 입장에서 파일 입출력은 통신이다. 프로세스가 입출력 관리 프로세스에 쓰기를 요구하면 데이터가 저장되고, 읽기를 요구하면 데이터를 가져오기 때문이다.

운영체제 입장에서는, 저장장치의 데이터를 읽고 쓰는 것도 일반 프로세스와 입출력 프로세스 간의 통신이다.

- 부모-자식 관계 프로세스 간 통신에 많이 이용
- 운영체제가 프로세스 동기화를 제공하지 않음 : 주로 부모 프로세스가 wait() 함수를 이용해 자식 프로세스의 작업이 끝날 때까지 대기

### 3) 파이프를 이용한 통신

파이프를 운영체제가 제공하는 동기화 통신 방식.

파일 입출력처럼 open() 함수로 기술자를 얻고 작업을 한 후 close() 함수로 마무리한다.

단방향 통신이기 때문에 양방향 통신을 하려면 파이프 2개를 사용해야 한다.

![https://user-images.githubusercontent.com/57691894/192104157-6bfdf5f0-dc6d-45d9-a7c2-ba6653294690.png](https://user-images.githubusercontent.com/57691894/192104157-6bfdf5f0-dc6d-45d9-a7c2-ba6653294690.png)

프로세스B가 파이프1에 대해 읽기 연산을 수행했는데 A가 파이프1에 아직 쓰기 연산을 하지 않았다면 B는 대기 상태가 된다. 대기 상태는 A가 파이프1에 데이터를 쓰는 순간 자동으로 풀려 동기화가 이루어진다. 즉, B는 *바쁜 대기*를 하지 않아도 된다.

- 이름 없는 파이프anonymous pipe : 일반적 파이프를 의미. 부모와 자식 프로세스 혹은 같은 부모를 가진 자식 프로세스와 같이 서로 관련 있는 프로세스 간 통신에 사용.
- 이름 있는 파이프named pipe : FIFO라 불리는 특수 파일을 이용하며 서로 관련 없는 프로세스 간 통신에 사용.

### 4) 소켓을 이용한 통신

네트워킹 상황 즉, 다른 컴퓨터에 있는 프로세스 간 통신은 소켓을 이용한다.

다른 컴퓨터의 위치를 파악하고, 원격지의 시스템 내 여러 프로세스 중 어떤 프로세스와 통신 할지 결정한다. 이때 통신하고자 하는 프로세스는 소켓에 쓰기 연산을 하면 데이터가 전송되고, 읽기 연산을 하면 데이터를 받게 된다.

동기화를 지원한다. (=데이터를 받는 쪽은 *바쁜 대기*를 하지 않는다.)

양방향 통신을 위해 파이프는 2개를 사용했지만 소켓은 하나만 사용한다.

### 5) 정리

- 프로세스 간 데이터를 주고받는 행위 : 읽기와 쓰기 연산
- 부모-자식 관계의 프로세스 : 전역 변수/파일/이름 없는 파이프로 통신
- 서로 독립적인 프로세스 : 이름 있는 파이프로 통신
- 서로 다른 시스템의 프로세스 : 소켓으로 통신
- 동기화를 지원하는 프로세스 : open()과 close() 함수 사용
- open-read / write-close 구조 : 파일/파이프/소켓에 적용

![https://user-images.githubusercontent.com/57691894/192104709-bcfeada1-fb1c-4d51-8097-9a56ea1bb9ed.png](https://user-images.githubusercontent.com/57691894/192104709-bcfeada1-fb1c-4d51-8097-9a56ea1bb9ed.png)