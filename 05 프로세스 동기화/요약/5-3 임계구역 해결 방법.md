# 5-3 임계구역 해결 방법

임계구역 문제를 해결하는 단순한 방법 : 잠금 (lock) 이용 

예를 들어 임계구역이 화장실이라면 사용자는 화장실 문을 잠그고 사용한 후 나올 때 잠금을 해제한다. 그리고 기다리는 사람이 있다면 사용해도 좋다는 신호를 보낸다. 잠금 해제와 동시에 동기화 신호를 보내는 것이다. 

또 다른 예로 임계구역이 믹서라면 사용자는 잠금을 걸고 믹서를 사용한 후 잠금을 풀면서 다음 사람에게 믹서를 사용해도 좋다는 신호를 보낸다. 

이 절에서는 임계구역 문제를 해결하기 위한 세 가지 조건인 상호 배제, 한정 대기, 진행기 융통성을 모두 만족하는 잠금, 잠금 해제, 동기화 구현 방법을 알아본다. 

---

# 1 기본 코드 소개

소프트웨어적으로 임계구역을 해결하는 방법 

다음은 가장 기본적인 코드로 boolean 변수는 true와 false 값만 가질 수 있으므로 잠금을 표현하기에 적합하다. 

그런데 C언어에는 boolean 변수가 없어서 새로 정의했다. 또한 잠금으로 사용할 전역 변수 lock과 임계구역에 사용할 예금 변수 balance도 정의했다. 

```c
// 기본 코드 
#include <stdio.h>

typedef enum {false, true} boolean;
extern boolean lock=false;
extern int balance;

main() {
	while(lock==true);
	lock=true;
	balance=balance+10; // 임계구역 
	lock = false;
}  
```

임계구역을 설명하려면 앞의 코드 2개를 놓고 분석해야 한다. 

임계구역은 한 순간에 한 프로세스만 접근할 수 있는 곳이므로, 2개의 코드를 놓고 임계구역에 동시에 접근하는 상황을 가정하고 설명하기 위해서이다. 그런데 2개의 코드를 놓고 분석하기에는 불필요한 부분이 많다. 

프로세스가 공유하는 변수는 ‘공유 변수’, 임계구역으로 보호되어야 할 부분은 ‘임계구역’이라고 표시할 것이다. 

---

# 2 임계구역 해결 조건을 고려한 코드 설계

## 2.1 상호 배제 문제

[그림 5-16]은 임계구역 문제를 해결하기 위한 첫 번째 코드이다. 프로세스 P1과 P2는 코드가 같으며 두 프로세스가 공유하는 변수인 lock의 초깃값은 false이다. 여기서 false는 잠금이 해제되었다는 의미이다. 

프로세스 P1과 P2는 임계구역에 진입하기 전에 코드를 통해 임계구역에 잠금이 걸려 있는지 확인한다(lock==true). 만약 잠겨있으면 다른 프로세스가 임계구역에서 작업하고 있다는 뜻이므로 잠금이 해제될 때까지 무한 루프를 돌면서 기다린다[while(lock==true);], 임계구역에 있는 프로세스가 작업을 마치고 잠금을 해제하면 (lock=false;) 무한 루프를 빠져나와 작업을 한다. lock=false;는 임계구역을 사용해도 좋다고 다른 프로세스에 보내는 동기화 신호이다. 잠금이 풀려서 새로 임계구역에 진입하는 프로세스는 다른 프로세스가 진입하지 못하도록 잠금을 걸고 (lock=true;) 작업을 하며, 작업을 마치면 다른 프로세스가 사용할 수 있도록 잠금을 해제한다(lock=false;) 

[그림 5-16]의 코드는 임계구역에 진입하기 전에 먼저 다른 프로세스가 사용 중인지 확인하며, 사용 중이면 끝날 때까지 기다리고 그렇지 앟으면 잠금을 걸고 임계구역에 진입한다. 그런데 이는 문제없이 작동할 것 같지만 가끔 제대로 작동하지 않는다. 어떤 상황에서 제대로 작동하지 않는지 [그림 5-17]을 통해 살펴보자 

위 그림에서는 임계구역에 진입한 프로세스가 없다(lock=false;). 이런 상황에서 아래 순서대로 실행된다고 가정해보자. 

1️⃣ 프로세스 P1은 while(lock==true); 문을 실행한다. 임계구역에 프로세스가 없기 때문에 무한루프를 빠져나온다. 그런데 이어서 다음 문장을 실행하려는 순간 자신에게 주어진 CPU 시간을 다 써서 (타임아웃) 준비 상태로 옮겨진다. 문맥 교환이 발생하고 프로세스 P2가 실행 상태로 바뀐다. 

2️⃣ 프로세스 P2는 while(lock==true); 문을 실행한다. 아직 프로세스 P1이 잠금을 걸지 않았기 때문에 lock은 여전히 false이며 프로세스 P2는 임계구역에 접근할 수 있다. 

3️⃣ 프로세스 P1은 lock=true; 문을 실행하여 임계구역에 잠금을 걸고 진입한다. 

4️⃣ 프로세스 P2도 lock=true; 문을 실행하여 임계구역에 잠금을 걸고 진입한다. 결국 둘 다 임계구역에 진입하게 된다. 

프로세스 P1은 1️⃣ while(lock==true); 문을 실행하고 나서 곧바로 3️⃣ lock=true; 문을 실행해야 다른 프로세스가 임계구역에 들어오는 것을 막을 수 있다. 그러나 프로세스 P1이 3️⃣ lock=true; 문을 실행하기 전에 프로세스 P2가 2️⃣ while(lock==true); 문을 실행하면 둘 다 임계지역에 진입하게 된다. 결국 [그림 5-17]과 같은 상황은 상호 배제 조건을 보장하지 못한다. 

[그림 5-17]의 또 다른 문제는 잠금이 풀리기를 기다리려면 바쁜 대기를 한다는 것이다. 바로 while(lock==true); 문 부분인데, 작업을 할 필요가 없는 시간에도 계속 무한 루프를 돌면서 시스템 자원을 낭비하게 된다. 

## 2.2 한정 대기 문제

[그림 5-18]은 상호 배제를 보장하지 못하는 [그림 5-17]의 문제를 보완하여 작성한 코드이다. 전역 변수로 lock1과 lock2를 사용하고 초깃값은 둘 다 false이다. 

프로세스 P1은 임계구역에 진입하기 전에 먼저 잠금을 설정하고 (lock1=true;) 프로세스 P2가 잠금을 설정했는지 확인한다. [while(lock2==true);], 만약 잠금을 설정하지 않았다면 임계구역에 진입하여 작업을 마친 후 잠금을 해제한다. (lock1 = false;). 프로세스 P2도 같은 방식으로 임계구역에 진입한다. 

[그림 5-17]에서는 임계구역에 잠금이 걸려 있는지 확인한 후 잠금을 건다. 만약 그 사이에 다른 프로세스가 진입하면 상호 배제 조건을 보장하지 못하고 두 프로세스의 임계구역 진입을 허락한다. 반면에 [그림 5-18]에서는 잠금을 2개 사용한다. 일단 잠금을 하고 프로세스가 잠겼는지 확인하므로 ***두 프로세스의 상호 배제가 보장된다.*** 

그런데 [그림 5-18]에서는 두 프로세스가 모두 임계구역에 진입하지 못하는 무한 대기 현상이 일어난다. 두 프로세스가 [그림 5-19]에 명시된 순서대로 실행된다고 가정해보자. 

1️⃣ 프로세스 P1은 lock1 = true; 문을 실행한 후 자신의 CPU 시간을 다 써버렸다. (타임아웃) 문맥 교환이 발생하고 프로세스 P2가 실행 상태로 바뀐다. 

2️⃣ 프로세스 P2도 lock2 = true; 문을 실행한 후 자신의 CPU 시간을 다 써버렸다. (타임아웃) 문맥 교환이 발생하고 프로세스 P1이 실행 상태로 바뀐다. 

3️⃣ 프로세스 P2가 lock2 = true; 문을 실행했기 때문에 프로세스 P1은 while(lock2 == true;) 문에서 무한 루프에 빠진다. 

4️⃣ 프로세스 P1이 lock1 = true; 문을 실행했기 때문에 프로세스 P2도 while(lock1 == true;) 문에서 무한 루프에 빠진다. 

결국 프로세스 P1과 P2 둘 다 while 문을 빠져나오지 못하고 무한 루프에 빠져서 임계구역에 진입하지 못한다. 이는 한정 대기 조건을 보장하지 못하는 상황으로 교착 상태(deadlock) 라고 한다. 교착 상태는 프로세스는 살아 있으나 작업이 진행되지 못하는 상태를 말한다. 교착 상태에 대해서는 6장에서 자세히 다룰 것이다. 

한편 [그림 5-18]에는 확장성 문제가 있다. 프로세스 P1은 자신의 lock1을 잠그고 lock2를 검사한다. 만약 프로세스가 3개라면 lock3을 만들고 다른 프로세스들이 lock3을 검사해야 한다. 이처럼 프로세스가 늘어나면 검사해야 하는 lock의 개수도 늘어나 비효율적이다. 

## 2.3 진행의 융통성 문제

[그림 5-20]은 [그림 5-17], [그림 5-18], [그림 5-19]에 비해 단순하다. 공유 변수 lock의 값을 통해 다른 프로세스가 임계구역에 있는지 확인하고, 없으면 진입한다. 프로세스 P1은 while(lock=2); 문을 실행하고 프로세스 P2가 잠금을 걸었으면 기다린다. [그림 5-20]에서는 lock=1 이기 때문에 프로세스 P1이 임계구역에 진입하고, 임계구역에 빠져나올 때 lock을 2로 바꾼다. 

***[그림 5-20]은 잠금을 확인하는 문장이 하나이므로 상호 배제와 한정 대기를 보장한다.*** 그러나 서로 번갈아가면서 실행된다는 것이 문제이다. 한 프로세스가 두 번 연달아 임계구역에 진입하고 싶어도 그럴 수 없다. [그림 5-20]은 프로세스의 우선순위에 상관없이 번갈아가며 임계구역에 진입한다. 프로세스 P1은 프로세스 P2가 임계구역에 진입했다가 나온 다음에야 다시 진입할 수 있으므로 프로세스 P2가 프로세스 P1의 진행을 방해하는 구조이다. 이렇게 프로세스의 진행이 다른 프로세스로 인해 방해받는 현상을 경직된 동기화 (lockstep synchronization)라고 한다. 즉 [그림 5-20]은 진행의 융통성 조건을 보장하지 못한다.  

## 2.4 하드웨어적인 해결 방법

임계구역 문제는 알고리즘을 이용한 소프트웨어적인 해결 방법 뿐만 아니라 하드웨어적인 방법으로도 간단히 해결할 수 있다. [그림 5-21]의 왼쪽 코드는 [그림 5-17]을 그대로 가져온 것이다. 앞에서 살펴보았듯이 이 코드는 잠금이 걸렸는지 검사하는 1️⃣ while (lock==true); 문과 검사한 후 잠금 설정을 하는 2️⃣ lock = true; 문이 분리되어 실행되면 (즉 두 명령어 중간에 타임아웃이 걸리면) 문제가 발생한다. 이 경우 하드웨어적으로 두 명령어를 동시에 실행하면 임계구역 문제를 쉽게 해결할 수 있다. 하드웨어의 도움을 받는 코드는 [그림 5-21]의 오른쪽 코드이다. 

왼쪽 코드의 1행과 2행은 오른쪽 코드의 1행과 같다. 이는 ‘검사와 지정 test-and-set’ 이라는 코드로 하드웨어의 지원을 받아 while(lock=true); 문과 lock=true; 문을 한꺼번에 실행한다. 검사와 지정 코드를 이용하면 명령어 실행 중간에 타임아웃이 걸려 임계구역을 보호하지 못하는 문제가 발생하지 않는다. 

임계구역을 하드웨어적으로 해결하는 방법은 편리하지만 바쁜 대기를 사용하여 검사하기 때문에 자원 낭비가 있다. 일부 하드웨어에서는 바쁜 대기 없이 잠금을 동기화해주기도 하지만, 이는 성능 좋은 하드웨어에서나 가능한 일이다. 

지금까지 소개한 알고리즘은 임계구역 해결 조건을 완벽하게 충족하지 못했다. 다음의 피터슨 알고리즘과 데커 알고리즘은 이러한 문제를 해결했으나 구조가 복잡하여 현재 잘 사용되지 않는다. 

---

# 3 피터슨 알고리즘

피터슨 알고리즘은 임계구역 문제를 해결하기 위해 게리 피터슨이 제안한 것이다. 

[그림 5-22]는 [그림 5-18]과 유사한데 turn이라는 공유 변수를 더 사용한다. 

프로세스 P1은 임계구역에 진입하기 전에 먼저 잠금을 한 (lock1 = true;) 후 turn을 2로 설정한다. 

변수 turn은 두 프로세스가 동시에 lock을 설정하여 임계구역에 못 들어가는 상황에 대비하기 위한 장치이다. 즉 두 프로세스가 동시에 lock을 설정했더라도 turn을 사용하여 다른 프로세스에 양보한다. 이어서 While(lock=2 == true && turn == 2); 문을 실행한다. 만약 프로세스 P2가 잠금을 설정하지 않았거나 잠금을 설정했더라도 곧바로 turn = 1로 바꾸면 프로세스 P1은 임계구역에 진입하여 작업을 마친 후 잠금을 해제하고 임계구역을 빠져나온다. 프로세스 P2도 같은 방식으로 임계구역에 진입한다. 

피터슨 알고리즘은 임계구역 해결의 세 가지 조건을 모두 만족하지만 2개의 프로세스만 사용가능하다는 한계가 있다. 여러 프로세스가 하나의 임계구역을 사용하려면 공유 변수를 추가하고 코드를 변경해야 한다. 

---

# 4 데커 알고리즘

테오도뤼스 데커가 제안한 데커 알고리즘도 임계구역 해결의 세 가지 조건을 모두 만족하는 알고리즘이다. 

지금까지 소개한 알고리즘 중 피터슨 알고리즘을 제외하고는 모두 임계구역 문제를 해결하기 위해 검사와 지정 같은 하드웨어의 도움이 필요했다. 다시 말해 연산 중간에 타임 아웃이 발생하지 않도록 하드웨어적으로 막아야 임계구역 문제가 해결되었다. 그러나 데커 알고리즘은 하드웨어의 도움 없이도 임계구역 문제를 해결할 수 있다는 것이 특징이다. 

데커 알고리즘이 어떻게 작동하는지 프로세스 P1의 입장에서 살펴보자. 

1️⃣ 프로세스 P1은 우선 잠금을 건다. (lock1 = true;) 

2️⃣ 프로세스 P2의 잠금이 걸렸는지 확인한다. [while(lock2 == true)]

3️⃣ 만약 프로세스 P2도 잠금을 걸었다면 누가 먼저인지 확인한다. [if (turn == 2)]. 만약 프로세스 P1의 차례라면 (turn = 1) 임계구역으로 진입한다. 만약 프로세스 P2의 차례라면 (turn = 2) 4️⃣ 로 이동한다. 

4️⃣ 프로세스 P1은 잠금을 풀고 (lock1 = false;) 프로세스 P2가 작업을 마칠 때까지 기다린다. [while(turn == 2);] 프로세스 P2가 작업을 마치면 잠금을 걸고 (lock1 = true;) 임계구역으로 진입한다. 

피터슨 알고리즘이나 데커 알고리즘은 임계구역 해결의 세 가지 조건을 모두 만족하지만 매우 복잡하다. 프로세스가 늘어나면 변수도 늘어나고 전체적인 알고리즘도 복잡해진다. 임계구역을 보호하기 위해 복잡한 알고리즘을 구현하도록 주문하는 것은 바람직한 접근 방법이 아니다. 

---

# 5 세마포어

앞에서 살펴본 임계구역 해결 알고리즘은 바쁜 대기를 사용하여 자원을 낭비하고 알고리즘도 너무 복잡하다. 이러한 단점을 해결하기 위해 에츠허르 데이크스트라 Edsger Dijkstra는 세마포어 semaphore라는 알고리즘을 제안했다. 세마포어는 앞의 알고리즘과 비교하여 간단하고 사용하기도 쉽다. 

세마포어는 임계구역에 진입하기 전에 스위치를 사용중으로 놓고 임계구역으로 들어간다. 이후에 도착하는 프로세스는 앞의 프로세스가 작업을 마칠 때까지 기다린다. 프로세스가 작업을 마치면 세마포어는 다음 프로세스에 임계구역을 사용하라는 동기화 신호를 보낸다. 세마포어는 다른 알고리즘과 달리 임계구역이 잠겼는지 직접 점검하거나, 바쁜 대기를 하거나, 다른 프로세스에 동기화 메시지를 보낼 필요가 없다. 

[그림 5-25]는 세마포어를 구현한 간단한 코드이다. 세마포어는 사용 전에 초기 설정[Semaphore(n)]을 하는데, 이때 n은 공유 가능한 자원의 수를 나타낸다. 예를 들어 프린터가 1대이면 1, 2대면이면 2가 된다. 세마포어는 초기화가 끝난 후 임계구역에 들어가기 전에 사용 중이라고 표시하고 [P()] 임계구역을 나올 때 비었다고 표시하는 [V()] 간단한 방법으로 임계구역을 보호한다. 

세마포어가 어떻게 작동하는지 [그림 5-26]의 세마포어 내부 코드를 통해 알아보자. 

- Semaphore(n) : 전역 변수 RS를 n으로 초기화한다. RS에는 현재 사용 가능한 자원의 수가 저장된다.
- P() : 잠금을 수행하는 코드로, RS가 0보다 크면 (사용 가능한 자원이 있으면) 1만큼 감소시키고 임계구역에 진입한다. 만약 RS가 0보다 작으면 (사용 가능한 자원이 없으면) 0보다 커질 때까지 기다린다.
- V() : 잠금 해제와 동기화를 같이 수행하는 코드로, RS 값을 1 증가시키고 세마포어에서 기다리는 프로세스에게 임계구역에 진입해도 좋다는 wake_up 신호를 보낸다.

대기할 때는 block() 코드를 사용한다. 

세마포어에서 잠금이 해제되기를 기다리는 프로세스는 세마포어 큐에 저장되어 있다가 wake_up 신호를 받으면 큐에서 나와 임계구역에 진입한다. 따라서 바쁜 대기를 하는 프로세스가 없다. 그러나 세마포어의 P()나 V() 내부 코드가 실행되는 도중에 다른 코드가 실행되면 상호 배제와 한정 대기 조건을 보장하지 못한다. 그러므로 P()와 V()의 내부 코드는 검사와 지정을 사용하여 분리 실행되지 않고 완전히 실행되게 해야 한다. 

[그림 5-27]은 [그림 5-10]에서 예금 5만원이 사라진 문제를 세마포어를 사용하여 해결한 코드이다. 세마포어의 P()와 V()를 사용하면 바쁜 대기 없이 간단하게 임계구역 문제를 해결할 수 있다. 공유 자원은 예금 하나이므로 RS의 초기값은 1이다. 

1️⃣ 먼저 도착한 프로세스 P1이 임계구역에 진입한다. 현재 RS는 1이므로 이 값을 1 감소시키고 임계구역에 진입한다. 

2️⃣ 나중에 도착한 프로세스 P2는 현재 PS 값이 0이므로 프로세스 P1이 임계구역을 빠져나올 때까지 세마포어 큐에서 기다린다. 

3️⃣ 프로세스 P1은 현재 예금이 10만원인 것을 확인하고 10만원을 더해 20만원으로 바꾼 다음 작업을 마친다. 

4️⃣ 프로세스 P1()은 V()를 실행하여 RS 값을 1 증가시키고 wake_up 신호를 프로세스 P2에 보낸다. 

5️⃣ wake_up 신호를 받은 프로세스 P2가 작업을 시작한다. 프로세스 P2는 현재 예금이 20만원인 것을 확인하고 5만원을 더해 25만원으로 바꾼다. 

세마포어는 공유 자원이 여러 개일 때도 사용할 수 있다. [그림 5-28]은 세마포어를 사용하여 2개의 공유 자원을 가지고 3개의 프로세스가 작업하는 예를 나타낸 것이다. 이는 프린터 2대를 3명이 동시에 사용하는 것과 같은 경우이다. 공유 자원이 2개이므로 Semaphore(n)의 초기값이 2이다. 

1️⃣ 프로세스 P1은 RS 값을 1 감소시키고 임계구역에 진입한다. 

2️⃣ 프로세스 P2도 RS 값을 1 감소시키고 임계구역에 진입한다. 

3️⃣ 프로세스 P3은 RS 값이 0이므로 다른 프로세스가 임계구역을 빠져나올 때까지 (RS가 0보다 커질 때까지) 기다린다. 

4️⃣ 프로세스 P1이 작업을 마치고 V()를 실행하면 RS 값은 1이 되고 wake_up 신호가 프로세스 P3에 전달된다. 

5️⃣ 프로세스 P3이 임계구역에 진입한다. 

---

# 6 모니터

세마포어는 피터슨 알고리즘이나 데커 알고리즘보다 단순하고 사용하기 편리하지만 문제가 없는 것은 아니다. 세마포어의 가장 큰 문제는 잘못된 사용으로 인해 임계구역이 보호받지 못한다는 것이다. [그림 5-29]는 사용자가 고의로 세마포어를 사용하지 않거나 사용 중에 실수를 해서 문제가 생긴 경우이다. 

1️⃣ 프로세스가 세마포어를 사용하지 않고 바로 임계구역에 들어간 경우에 임계구역을 보호할 수 없다. 

2️⃣ P()를 두 번 사용하여 wake_up 신호가 발생하지 않은 경우이다. 프로세스 간의 동기화가 이루어지지 않아 세미포어 큐에서 대기하고 있는 프로세스들이 무한 대기에 빠진다. 

3️⃣ P()와 V()를 반대로 사용하여 상호 배제가 보장되지 않은 경우에 임계구역을 보호할 수 없다. 

공유 자원을 사용할 때 모든 프로세스가 세마포어 알고리즘을 따른다면 굳이 P()와 V()를 사용할 필요 없이 자동으로 처리하면 된다. 이를 실제로 구현한 것이 모니터 (monitor) 이다. 모티너는 공유 자원을 내부적으로 숨기고 공유 자원에 접근하기 위한 인터페이스만 제공함으로서 자원을 보호하고 프로세스 간에 동기화를 시킨다. 

모니터는 시스템 호출과 같은 개념이다. 커피 머신을 사용자가 직접 만지면 고장날 가능성이 높아지는 것처럼, 운영체제가 관리하는 자원을 사용자가 마음대로 사용하게 두면 실수나 악의적인 의도로 시스템 자원을 망가뜨릴 수 있다. 이러한 문제를 예방하기 위해 운영체제는 시스템 자원을 사용자로부터 숨기고 사용자의 요구 사항을 처리할 수 있는 인터페이스만 제공하는데, 이를 시스템 호출이라고 한다. 

시스템 호출과 같은 방법으로 모니터도 보호할 자원을 임계구역으로 숨기고 임계구역에서 작업할 수 있는 인터페이스만 제공하여 자원을 보호한다. [그림 5-30]은 모니터의 작동 원리를 나타낸 것이다. 

1️⃣ 임계구역으로 지정된 변수나 자원에 접근하고자 하는 프로세스는 직접 P()나 V() 를 사용하지 않고 모니터에서 작업 요청을 한다. 

2️⃣ 모니터는 요청받은 작업을 모니터 큐에 저장한 후 순서대로 처리하고 그 결과만 해당 프로세스에 알려준다. 

[그림 5-31]은 [그림 5-30]에서 예금 5만원이 사라진 문제를 모니터를 사용하여 해결한 코드이다. 사용자가 잠금이나 세마포어를 사용하지 않고 입금하라는 명령, 즉 increase() 문만 사용한다. 모니터는 프로세스 P1과 P2의 요청을 모니터 큐에 넣은 후 순서대로 실행하고 그 결과만 해당 프로세스에 알려준다. 이 방법은 사용자 입장에서는 복잡한 코드를 실행하지 않아서 좋고, 시스템 입장에서는 임계구역을 보호할 수 있어서 좋다. 

다음은 [그림 5-31]의 코드를 자바로 작성한 것이다. 자바는 C언어와 달리 내부적으로만 보이는 private 영역과 외부에서 접근 가능한 public 영역으로 나뉜다. private 영역에 정의된 변수는 외부에서 볼 수 없으며, public 영역에 정의한 함수를 통해서만 변숫값을 변경할 수 있다. 

```java
// 자바로 작성한 모니터 내부 코드 

monitor shared_balance {
	private:
		int balance = 10; // shared data
		boolean busy = false;
		condition mon; // condition variable 

	public:
		increase(int amount) { // public interface
			if (busy == true) mon.wait(); // waiting in queue 
			busy = true;
			balance = balance + amount;
			mon.signal();
	}
```

위 코드에서 10만원이 들어 있는 예금 balance, 잠금 역할을 하는 busy, 잠금 해제 역할을 하는 mon 변수는 private으로 선언되어 있다. 이 변수는 public 영역에 있는 increase() 를 통해서만 값을 변경할 수 있다. 다시 말해 입금하려는 프로세스는 increase()만 사용하여 예금 데이터에 접근할 수 있다. 이 상황에서 프로세스 P1은 increase(10)을, 프로세스 P2는 increase(5)를 사용하면 입금이 끝난다. increase는 임계구역이 잠겼는지 busy 확인하고 다른 프로세스가 사용하지 않으면 잠금을 건 후 예금액을 증가시킨다. 모니터를 사용하면 세마포어의 P() 와 V()를 사용할 필요가 없다. 임계구역의 보호나 프로세스의 동기화가 모니터 내부에서 처리되므로 사용자느 increase()를 호출하기만 하면 된다. 

모니터는 임계구역 보호와 동기화를 위해 내부적으로 상태 변수 condition variable 을 사용한다. 

상태 변수에는 wait()와 signal() 기능이 있는데 [그림 5-32]에서는 상태 변수가 mon이다. 

- wait() : 모니터 큐에서 자신의 차례가 올 때까지 기다린다. 세마포어의 P()에 해당한다.
- signal() : 모니터 큐에서 기다리는 다음 프로세스에 순서를 넘겨준다. 세마포어의 V()에 해당한다.

불필요한 정보를 숨기고 공유 자원에 대한 인터페이스만 제공하는 모니터는 오늘날의 객체지향 언어와 매우 닮았다.