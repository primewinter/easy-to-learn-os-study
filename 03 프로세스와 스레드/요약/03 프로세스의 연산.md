# 2-3. 프로세스의 연산

### 목표

- 프로세스의 구조 파악
- 프로세스의 생성, 복사, 전환 개념 파악

---

## 1. 프로세스의 구조

프로세스의 주소 공간은 코드(code), 데이터(data), 스택(stack), 힙(heap) 영역으로 구성된다. 이러한 주소 공간을 우리는 가상 메모리 (또는 논리적 메모리: logical memory)라고 부른다.

**코드 영역(텍스트영역)**

프로그램의 본문이 기술된 곳.
프로그래머가 작성한 프로그램은 코드 영역에 탑재되며 탑재된 코드는 **읽기 전용**으로 처리 된다.


**데이터 영역**

코드에서 사용한 **변수**나 파일 등 각종 데이터를 모아 놓은 곳.
상수는 읽기 전용이지만 대부분의 변수는 **읽기/쓰기** 가능하다.


**스택 영역**

운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아 놓은 곳.
함수를 호출하면 함수를 수행하고 원래 프로그램으로 되돌아올 위치 저장.


## 2. 프로세스의 생성

사용자가 프로그램 실행

↓

운영체제는 프로그램을 코드 영역에 탑재, 프로세스 **제어 블록 생성**

↓

**메모리에** 데이터 영역과 스택 **영역을 확보**한 후 프로세스 실행

## 3. 프로세스의 복사

### fork() 시스템 호출

커널에서 제공하는 함수로, 일종의 시스템 호출

실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수

실행하던 프로세스는 부모 프로세스, 새로 생긴 프로세스는 자식 프로세스 관계

### **동작 과정**

 제어 블록을 포함한 부모 프로세스 영역의 대부분이 자식 프로세스에 복사

![https://user-images.githubusercontent.com/57691894/188247878-bec57982-39cb-48c8-a4ef-073d3b82403f.png](https://user-images.githubusercontent.com/57691894/188247878-bec57982-39cb-48c8-a4ef-073d3b82403f.png)

- 프로세스 구분자 PID 바뀜
- 부모 프로세스와 자식 프로세스가 차지하는 메모리의 위치가 다르므로 메모리 관련 정보 바뀜
- 부모 프로세스 구분자 PPID, 자식 프로세스 구분자 CPID 바뀜

### **장점**

**프로세스 생성 속도 빠르다.**

하드디스크로부터 프로그램을 새로 가져오지 않고 기존 메모리에서 복사하기 때문이다.

**추가 작업 없이 자원을 상속할 수 있다.**

부모 프로세서가 사용하던 모든 자원을 추가 작업 없이 자식 프로세스에 상속할 수 있다.

**시스템 관리를 효율적으로 할 수 있다.**

자식 프로세스를 종료하면 자식이 사용하던 자원(메모리 영역, 파일, 하드웨어 등)을 부모 프로세스가 정리할 수 있다. 

## 4. 프로세스의 전환

### exec() 시스템 호출

현재의 프로세스가 완전히 다른 프로세스로 전환

프로세스는 그대로 둔 채 내용만 바꾸는 시스템 호출(프로세스의 구조체 재활용)

### 동작 과정

![https://user-images.githubusercontent.com/57691894/188248459-d8934297-f6eb-4d57-a30f-ad9708f46273.png](https://user-images.githubusercontent.com/57691894/188248459-d8934297-f6eb-4d57-a30f-ad9708f46273.png)

- exec() 시스템 호출을 하면 코드 영역에 있는 기존의 내용을 지우고 새로운 코드로 바꾼다.
- 데이터 영역은 새로운 변수로 채워진다.
- 스택 영역은 리셋된다.
- 각종 프로세스 구분자(PID, PPID, CPID), 메모리 관련 사항은 변하지 않는다.

### 장점

이미 만들어진 프로세스 제어 블록, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있어 편리하다.

✅ 프로세스를 종료한 후 사용한 메모리를 청소(garbage collection)하기 위해 상위 프로세스와 부모-자식 관계를 만들어야 하는데, exec()는 부모-자식 관계를 그대로 유지하니 메모리 관리도 용이하다.

## 5. 프로세스의 계층 구조

유닉스의 예를 통해 프로세스의 계층 구조 파악하기

### 유닉스의 프로세스 계층 구조

![https://user-images.githubusercontent.com/57691894/188248762-3b79f69f-d6e6-4de6-841b-e82efe9b6f2b.png](https://user-images.githubusercontent.com/57691894/188248762-3b79f69f-d6e6-4de6-841b-e82efe9b6f2b.png)

(출처 : [https://velog.io/@cheal3/운영체제-프로세스와-스레드](https://velog.io/@cheal3/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C))

**init 프로세스는 전체 프로세스의 출발점**이다. 운영체제가 프로세스를 효율적으로 관리하기 위해서 나머지 프로세스를 전부 init 프로세스의 자식으로 만든다. 이때, **fork()와 exec()** 시스템 호출을 이용해서 **자식 프로세스를 만든다**.

### 프로세스 계층 구조의 장점

- **여러 작업의 동시 처리**
    
    예를 들어 사용자 3명이 동시에 컴퓨터에 접속한다면 동시에 3명을 처리해야 하는데, login 프로세스는 한 번에 한 명만 처리할 수 있다. 유닉스 운영체제는 fork()로 login 프로세스를 여러 개 만들어 사용자에게 나누어준다.
    
    로그인한 사용자들은 운영체제에 명령을 내리고 결과를 받으려면 shell 프로세스가 필요하다. 작업을 마친 login 프로세스의 구조를 활용하기 위해 exec()로 shell 프로세스로 전환시킨다.
    
    shell 프로세스에서 명령어로 응용 프로그램을 실행할 때에도 fork()를 통해 자식 프로세스를 만든 뒤, exec()를 통해 mplayer, chatting 등 프로세스로 바꾼다.
    
- **용이한 자원 회수**
    
    프로세스를 계층 구조로 만들면 프로세스 간의 책임 관계가 분명해져서 시스템 관리가 수월하다. 만약 모든 프로세스가 독립적으로 만들어지면 프로세스가 종료될 때마다 운영체제가 직접 자원을 회수해야 하기 때문에 복잡할 것이다. 그러나 부모-자식 관계로 프로세스를 만들면 프로세스 종료 시 부모가 자원 회수(garbage collection)하면 된다.
    

### 고아 프로세스와 좀비 프로세스

부모 프로세스는 자원을 회수하기 위해 자식 프로세스가 끝날 때까지 기다려야 한다.

부모 프로세스가 먼저 종료 되면 **고아 프로세스**(orphan process)라고 한다. **좀비 프로세스**(zombie process)는 자식 프로세스가 종료했음에도 부모가 뒤처리를 하지 않을 때 발생한다.

컴퓨터에 고아나 좀비 프로세스가 많아지면 자원이 낭비되므로 운영체제는 **주기적으로 자원 회수를 해야 한다.**

## 마치며

프로세스의 복사, 상속, 계층 구조는 현대 객체지향 프로그래밍 언어의 기본이다. 자바의 경우 객체가 상위 객체의 모든 특징을 상속하고, 모든 객체의 최상위에 Object 클래스가 있다. 자바는 자원 회수가 잘 되는 프로그래밍 언어 중 하나이다. 객체지향 프로그래밍 언어의 상속과 부모-자식 관계 구조는 상위 프로세스의 특징이 하위 프로세스에 상속되어 자원의 사용을 용이하게 하고, 객체를 다 사용하고 난 뒤에 자원이 쉽게 회수된다.
