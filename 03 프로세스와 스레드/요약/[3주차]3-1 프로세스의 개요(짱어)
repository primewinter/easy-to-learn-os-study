1. 프로세스란?
-> 하나의 작업 단위! 
   ex)사용자가 마우스를 더블클릭하여 프로그램으 실행하면 그 프로그램은 프로세스가 된다.

프로그램과 프로세스의 차이는?
폰노이마 구조에서 프로그램이 실행된다느 것은 해당 코드가 메모링 올라와서 작업이 진행된다는 의미.
프로그램 : 저장장치에 저장되어 있는 정적인 상태, 프로그램을 짠다, 작성한다고 표현. 어떤 데이터를 사용하여 어떤 작업을 할지 그 절차르 적어놓은 것.
프로세스 : 실행을 위해 메모리에 올라온 동적인 상태. 실행한다고 표현. 프로그램으로 작성된 작업 절차를 실제로 실행에 옮긴다는 의미. 

=> 따라서 누군가 작성한 프로그램이 실행되면 프로세스가 된다.

2. 일괄 작업 방식의 요리
-> 한번에 하나의 작업만을 처리한다.
ex) 레스토랑에 테이블이 하나만 있는 것과 같음. 손님 한명이 다 먹고 나가야 다음 작업이 가능.
    주문서를 받은 순서대로 하나씩 완료하는 것. => 작업 효율이 떨어짐.
    주방에서 기다리는 손님을 주문을 미리 받는다고 가정하자. 순서대로 주문 하기 위해 주문 목록을 사용하는데 주문 목록은 큐로 처리된다.

* 큐란? 
   -> 먼저 들어온 데이터가 먼저 빠져나가는 자료 구조.
* 스택이란?
   -> 큐와 반대로 먼저 들어온 데이터가 마지막에 빠져나간다.

큐는 양쪽이 뚫려 있는 파이프, 스택은 한쪽만 뚫려 있는 파이프라고 생각하면 된다.

테이블이 여러개 있는 레스토랑에서 일괄 작업 방식은 매우 비효율적

3. 시분할 방식
    요리사는 한명이지만 시간을 적당히 배분하여 여러 가지 요리를 동시에 하는 시분할 방식은 효율적.
    Cpu가 1개인 컴퓨터에서 여러개의 프로세스를 동시에 실행하는 것도 같은 원리.
    cpu가 시간을 쪼개어 여러 프로세스에 적당히 배분함으로써 동시에 실행하는 것 처럼 느낌.

    => 주문서는 아주 중요한 역할을 한다. 손님의 요구사항, 현재 진행 상황 등이 나타나있다. 주문서의 모든 요리가 제공되면 주문서는 주문 목록에서 삭제된다.

    요리의 시작 : 주문서가 주문 목록에 올라온다.
    요리 중 : 주문서는 주문 목록에서 대기하거나 요리사가 요리하는 상태를 왕복
    요리 작업 종료 : 모든 요리가 제공되면 주문 목록에서 삭제

4. 시분할 방식에서 예상치 못한 상황 처리
     시분할 방식을 이용한 요리는 여러 목록을 옮겨 가면서 진행됨. 운영체제에서 프로세스의 처리도 이와 유사하다. 

5. 프로그램에서 프로세스로의 전환
      태스크 : 컴퓨터 시스템의 작업 단위로 프로세스를 일컫는 다른 용어.

      시분할 방식 시스템에서 프로그램이 프로세스로 전환될 때
      -> 운영체제는 프로그램을 메모리의 적당한 위치로 가져온다.
      -> 동시에 주문서에 해당하는 작업 지시서를 만든다.
      -> 주문서에는 각종 요구사항들이 있는데 이 작업 지시서가 ‘프로세스 제어 블록’이다. 주문서가 없으면 요리가 진행되지 않 듯 프로세스 제어 블록이 없으면 프로그램이 프로세스로 전환되지 못한다.

      => 어떤 프로그램이 프로세스가 되었다는 것은 운영체제로부터 프로세스 제어 블록을 받았다는 의미.

      * 프로세스 구분자
       -> 메모리에 존재하는 여러 개의 프로세스를 구분하기 위한 구분자가 필요한데, 레스토랑 주문서의 일련번호 처럼 프로세스를 구분하기 위해 프로세스 구분자가 있다.

      * 메모리 관련 정보
       -> cpu는 실행하려는 프로세스가 메모리의 어디에 저장되어 있는지를 알아야 작업을 할 수 있다. 
          이를 위해 프로세스 제어 블록에는 프로세스의 메모리 위치 정보가 담겨 있다. 메모리 보호를 위한 경계 레지스터와 한계 레지스터도 포함

      * 각종 중간값
       -> 프로세스 제어 블록에는 프로세스가 사용한 중간값이 저장된다. 
          시분할 시스템에서는 여러 프로세스가 번갈아가며 실행되기 때문에 각 프로세스는 일정 시간 작업을 한 후 다른 프로세스에 cpu를 넘겨준다.

      Ex) 프로세스 a가 103번 행까지 작업 후 다른 프로세스에 cpu를 넘겨주었다고 가정.
        -> a가 다시 104번 행부터 작업을 시작해야할 때, 프로세스 제어 블록에는 다음에 작업해야할 코드의 위치가 담긴 레지스터인 프로그램 카운터가 저장됨. 
           작업의 중간값을 보관 중인 다른 레지스터도 같이 저장. 이 저장된 값은 작업을 계속 진행할 수 있게 해줌.

      => 결론적으로, 하나의 프로세스를 실행하려면 프로세스 구분자, 메모리 관련 정보, 프로그램 카운터와 각종 레지스터 같은 중간값을 관리해야 함. 
         이러한 정보를 보관하는 데이터 구조가 ‘프로세스 제어 블록’이다. 프로그램이 프로세스가 되려면 메모리에 올라오는 것과 동시에 프로세스 제어 블록이 생성되어야 한다. 

      => 프로세스 제어 블록은 운영체제가 해당 프로세스를 위해 관리하는 데이터 구조이기 때문에 운영체제 영역에 만들어진다. 
         프로세스가 종료되면 프로세스가 메모리에서 삭제되고 프로세스 제어 블록도 폐기된다.

         프로그램이 프로세스가 된다는 것은 운영체제로부터 프로세스 제어 블록을 얻는다는 뜻이고, 프로세스가 종료된다는 것은 해당 프로세스 제어 블록이 폐기된다는 뜻

         프로세스 = 프로그램 + 프로세스 제어 블록
         프로그램 = 프로세스  - 프로세스 제어 블록

