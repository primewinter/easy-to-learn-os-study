스케줄링 알고리즘
  비선점형 알고리즘 : 프로세스가 CPU를 할당받으면 작업이 끝날때까지 CPU를 놓지 않아 효율이 떨어지므로 사용x
    ex. FCFS 스케줄링, SJF스케줄링, HRN스케줄링
  선점형 알고리즘 : 시분할 시스템을 고려하여 만들어진 알고리즘. 어떤 프로세스가 CPU를 할당받아 실행중이라도 운영체제가 CPU를 강제로 빼았을 수 있다.
    ex. 라운드 로빈 스케줄링, SRT스케줄링, 다단케 큐 스케줄링, 다단계 피드백 큐 스케줄링
    
스케줄링 알고리즘 평가 기준
1. CPU 사용률 : 전체 시스템 동작 시간 중 CPU가 사용된 시간 측정
2. 처리량     : 단위 시간당 작업을 마친 프로세스의 수. 수치가 클수록 좋은 알고리즘
3. 대기 시간  : 작업을 요청한 프로세스가 작업을 시작하기 전까지 대기하는 시간. 짧을수록 좋다.
4. 응답 시간  : 프로세스 시작 후 첫 번째 출력 또는 반응이 나올 때까지 걸리는 시간. 짧을수록 좋다.
               (대화형 시스템에서는 사용자의 요구에 얼마 만에 반응하는지가 중요)
5. 반환 시간  : 프로세스가 생성 된 후 사용하던 자원을 모두 반환하는 데까지 걸리는 시간. 반환 시간 = 대기 시간 + 실행 시간

FCFS 스케줄링
-> 준비 큐에 도착한 순서대로 CPU를 할당하는 비선점형방식으로, 선입선출 스케줄링이라고도 한다. 프로세스가 큐에 도착한 순서대로 실행. 한번 실행되면 프로세스가 끝나야만
   다음 프로세스를 실행할 수 있다. 큐가 하나라 모든 프로세스는 우선순위가 동일하다.
-> 단순하고 공평하지만, 콘보이 효과(호위 효과)가 발생
    콘보이 효과 : 처리시간이 긴 프로세스가 CPU를 차지하면 다른 프로세스들은 하염없이 기다려 시스템의 효율성이 떨어지는 문제가 있음.
                 즉, 컨베이어 벨트에 작업물이 한 줄로 늘어서 있을 때 앞의 작업이 오래 걸려서 뒤의 작업이 지연되는 현상.

SJF 스케줄링
-> 준비 큐에 있는 프로세스 중에서 실행 시간이 가장 짧은 작업부터 CPU를 할당하는 비선점형 방식. 최단 작업 우선 스케줄링이라고도 함.
   CPU를 배정할 때 시간이 오래 걸리는 작업이 앞에 있고 간단한 작업이 뒤에 있으면 그 순서를 바꿔서 실행. 콘보이 효과를 완하하여 시스템의 효율성을 높이는 것.
-> 작업을 먼저 실행하기 때문에 시스템의 효율성이 좋아짐. 하지만 아래와 같은 이유로 사용이 힘들다.

1. 운영체제가 프로세스의 종료 시간을 정확하게 예측하기 어렵다.
  -> 현대의 프로세스는 사용자와의 상호작영이 빈번히 발생하므로 프로그램 종료 시각을 파악하기 어렵다.
  -> 현대의 운영체제에서는 프로세스의 작업 길이를 추정하는 것이 어렵다.
2. 공평하지 못하다.
  -> 아사 현상(무한 봉쇄 현상)이 발생한다.
     아사 현상(무한 봉쇄 현상) : 작업 시간이 긴 프로세스는 짧은 프로세스가 들어오면 작업이 계속해서 뒤로 밀리게 되는 현상.
 
HRN 스케줄링
-> SJF 스케줄링에서 발생할 수 있는 아사 현상을 해결 하기 위해 만들어진 비선점형 알고리즘. 최고 응답률 우선 스케줄링이라고도 함.
-> 서비스를 받기 위해 기다린 시간과 CPU 사용 시간을 고려하여 스케줄링하는 방식
-> 프로세스의 우선순위를 결정하는 기준 => (대기 시간 + CPU 사용시간) / CPU 사용 시간
-> 우선순위를 정할 때 대기시간을 고려함으로써 아사 현상을 완화. 스케줄링 방식에 에이징을 구현한 셈
  에이징 : 프로세스가 양보할 수 있는 상한선을 정하는 방식.
-> 하지만 공평성이 위배되어 많이 사용되지 않음

라운드 로빈 스케줄링
-> 한 프로세스가 할당받은 시간(타임 슬라이스) 동안 작업을 하다가 작업을 완료하지 못하면 준비 큐의 맨 뒤로 가서 자기 차례를 기다리는 방식.
-> 선점형 알고리즘 중 가장 단순하고 대표적인 방식. 프로세스들이 작업을 완료할 때까지 계속 순환하면서 실행됨.
-> 각 프로세스마다 CPU를 사용할 수 있는 최대시간, 즉 타임 슬라이스가 존재. 우선순위가 적용되지 않은 가장 단순한 선점형 스케줄링 방식.
-> 라운드 로빈 스케줄링과 FCFS 스케줄링의 평균 대기 시간이 같다면 라운드 로빈 스케줄링이 더 비효율적인 알고리즘이다. 같은 선점형 방식에서는 문맥 교환 시간이 추가되기 때문
-> 라운드 로빈 스케줄링이 효과적으로 작동하려면 문맥 교환에 따른 추가 시간을 고려하여 타임 슬라이스를 적절히 설정해야 함.
    * 타임 슬라이스가 큰 경우
      -> 타임 슬라이스가 너무 크면 하나의 작업이 끝난 뒤 다음 작업이 시작되는 것처럼 보이므로 이 경우 FCFS 스케줄링과 다를 게 없다.
    * 타임 슬라이스가 작은 경우
      -> 매우 작은 값으로 설정하면 사용자는 여러 프로그램이 동시에 실행되는 것처럼 느낄 것. 그러나 타임 슬라이스를 너무 작게 설정하면 시스템의 전반적인 성능이 떨어진다.
   결론적으로 타임 슬라이스는 되도록 작게 설정하되 문맥 교환에 걸리는 시간을 고려하여 적당한 크기로 하는 것이 중요하다.
   
SRT 우선 스케줄링
-> SJF 스케줄링과 라운드 로빈 스케줄링을 혼합한 방식으로, 최소 잔류 시간 우선 스케줄링이라고도 한다. 쉽게 말해 SJF 스케줄링의 선점형 버전이라고 할 수 있음.
-> CPU를 할당받을 프로세스를 선택할 때 남아 있는 작업 시간이 가장 적은 프로세스를 선택한다. 라운드 로빈 스케줄링이 큐에 있는 순서대로 CPU를 할당한다면, 
   SRT 스케줄링은 남은 시간이 적은 프로세스에 CPU를 먼저 할당한다.
-> SJF 스케줄링과 SRT 스케줄링의 평균 대기 시간을 비교해보면 SRT 스케줄링이 평균 대기 시간이 짧다. 하지만 좋은 알고리즘은 아님. 현재 실행 중인 프로세스와 큐에 있는 프로세스의
   남은 시간을 계산하고, 남은 시간이 더 적은 프로세스와 문맥 교환을 해야하므로 작업이 추가되고, 프로세스의 종료 시간 예측이 어려우며 아사 현상이 일어나기 때문에 잘 사용하지 않음.

우선순위 스케줄링
-> 중요도에 따라 우선순위를 갖는데 이러한 우선순위를 반영한 스케줄링 알고리즘. 어떤 기준으로 우선순위를 정하느냐에 따라 다양하게 구현 가능.
-> 우선순위는 비선점형 방식과 선점형 방식에 모두 적용할 수 있다.
-> 우선순위 알고리즘은 고정 우선순위 알고리즘과 변동 우선순위 알고리즘으로 나뉜다.
  * 고정 우선순위 알고리즘 : 한번 우선순위를 부여받으면 종료될 때 까지 우선순위가 고정. 시시각각 변하는 시스템의 상황을 반영하지 못해 효율성이 떨어짐.
  * 변동 우선순위 알고리즘 : 일정 시간마다 우선순위가 변함. 시스템이 복잡하지만 시스템의 상황을 반영하여 효율적인 운영이 가능.
우선순위는 시스템의 효율성이 아니라 프로세스의 중요도를 기준으로 결정된다. 

다단계 큐 스케줄링
-> 우선순위에 따라 준비 큐를 여러개 사용하는 방식.
-> 프로세스는 운영체제로부터 부여받은 우선순위에 따라 해당 우선순위의 큐에 삽입된다.
라운드 로빈 방식으로 운영되는 큐는 우선순위에 따라 다단계로 나뉘어 있어 프로세스가 큐에 삽입되는 것 만으로 우선순위가 결정됨.
-> 우선순위에 따라 다양한 스케줄링이 가능한 선점형 방식. 우선순위가 높은 프로세스가 우선순위가 낮은 프로세스보다 먼저 작동할 수 있음. 우선순위에 따라 타임 슬라이스를 조절하여
작업 효율을 높일 수 있다.
하지만, 우선순위가 높은 상위 큐 프로세스의 작업이 끝나기 전에는 하위 큐 프로세스의 작업을 할 수 없다. 우선순위가 1번인 큐에 CPU 할당을 기다리는 프로세스가 있다면 우선순위가
2번인 큐의 프로세스는 1번 큐에 있는 프로세스의 작업이 끝날 때까지 기다려야한다. 즉 우선순위가 높은 프로세스 때문에 우선순위가 낮은 프로세스의 작업이 연기되는데 이런 문제를
해결하기 위해 다단계 피드백 큐 스케줄링이 나옴.

다단계 피드백 큐 스케줄링
-> 우선순위가 낮은 프로세스에 불리한 다단계 큐 스케줄링의 문제점을 보완한 방식.
-> CPU를 사용하고 난 우선순위가 낮아진다. CPU를 사용하고 난 프로세스는 원래의 큐로 돌아가지 않고 우선순위가 하나 낮은 큐의 끝으로 들어간다.
-> 우선순위에 따라 타임 슬라이스의 크기가 다르다는 것
-> 오늘날의 운영체제가 CPU스케줄링을 위해 일반적으로 사용하는 방식.
-> 변동 우선순위 알고리즘의 전형적인 예.
  
